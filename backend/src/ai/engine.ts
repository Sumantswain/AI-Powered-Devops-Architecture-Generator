import { z } from 'zod';

export const ArchitectureInputSchema = z.object({
  appType: z.string(),
  trafficScale: z.string(),
  highAvailability: z.boolean(),
  region: z.string(),
});

export type ArchitectureInput = z.infer<typeof ArchitectureInputSchema>;

export interface ArchitectureJson {
  vpc: boolean;
  ec2: number;
  alb: boolean;
  rds: string | null;
  autoscaling: boolean;
  region: string;
  s3: boolean;
  cloudfront: boolean;
  privateSubnets: boolean;
  publicSubnets: boolean;
}

export interface AiOutputs {
  architectureJson: ArchitectureJson;
  terraform: string;
  cicdYaml: string;
  costBreakdown: {
    totalMonthly: number;
    services: Record<string, number>;
  };
  scalabilityScore: number;
}

// NOTE: This is a rule-based engine structured to be easily
// swapped with a real LLM call while preserving prompts.
export class AiEngine {
  generateArchitecture(input: ArchitectureInput): AiOutputs {
    const { appType, trafficScale, highAvailability, region } = input;

    const baseInstances =
      trafficScale === 'low' ? 1 : trafficScale === 'medium' ? 2 : 4;

    const architectureJson: ArchitectureJson = {
      vpc: true,
      ec2: baseInstances,
      alb: trafficScale !== 'low',
      rds: appType === 'ml' ? null : highAvailability ? 'multi-az' : 'single-az',
      autoscaling: highAvailability || trafficScale === 'high',
      region,
      s3: true,
      cloudfront: trafficScale !== 'low',
      privateSubnets: true,
      publicSubnets: true,
    };

    const terraform = this.generateTerraform(architectureJson, input);
    const cicdYaml = this.generateGitHubActionsYaml(input);
    const costBreakdown = this.estimateCost(architectureJson);
    const scalabilityScore = this.computeScalabilityScore(architectureJson);

    return {
      architectureJson,
      terraform,
      cicdYaml,
      costBreakdown,
      scalabilityScore,
    };
  }

  private generateTerraform(arch: ArchitectureJson, input: ArchitectureInput): string {
    return [
      '# Terraform skeleton generated by AI engine',
      'provider "aws" {',
      `  region = "${arch.region}"`,
      '}',
      '',
      'resource "aws_vpc" "main" {',
      '  cidr_block = "10.0.0.0/16"',
      '  tags = {',
      `    Name = "devops-arch-${input.appType}"`,
      '  }',
      '}',
      '',
      arch.autoscaling
        ? 'resource "aws_autoscaling_group" "app_asg" {\n  # ... autoscaling group config ...\n}'
        : 'resource "aws_instance" "app" {\n  # ... EC2 instance config ...\n}',
      '',
      arch.rds
        ? 'resource "aws_db_instance" "db" {\n  # ... RDS configuration with multi-AZ if enabled ...\n}'
        : '# No RDS defined for this workload',
      '',
      'resource "aws_s3_bucket" "assets" {\n  # ... S3 bucket for static assets ...\n}',
    ].join('\n');
  }

  private generateGitHubActionsYaml(input: ArchitectureInput): string {
    return [
      'name: CI/CD Pipeline',
      '',
      'on:',
      '  push:',
      '    branches: [ main ]',
      '',
      'jobs:',
      '  build-and-deploy:',
      '    runs-on: ubuntu-latest',
      '    steps:',
      '      - name: Checkout',
      '        uses: actions/checkout@v4',
      '',
      '      - name: Set up Node',
      '        uses: actions/setup-node@v4',
      '        with:',
      '          node-version: 20',
      '',
      '      - name: Install dependencies',
      '        run: npm install',
      '',
      '      - name: Run tests',
      '        run: npm test',
      '',
      '      - name: Deploy infrastructure',
      '        uses: hashicorp/setup-terraform@v3',
      '      - run: terraform init && terraform apply -auto-approve',
      `      # Environment: ${input.appType} in ${input.region}`,
    ].join('\n');
  }

  private estimateCost(arch: ArchitectureJson): {
    totalMonthly: number;
    services: Record<string, number>;
  } {
    const ec2Cost = arch.ec2 * 50;
    const rdsCost = arch.rds === 'multi-az' ? 250 : arch.rds ? 120 : 0;
    const albCost = arch.alb ? 25 : 0;
    const s3Cost = arch.s3 ? 15 : 0;
    const cloudfrontCost = arch.cloudfront ? 30 : 0;

    const services = {
      EC2: ec2Cost,
      RDS: rdsCost,
      ALB: albCost,
      S3: s3Cost,
      CloudFront: cloudfrontCost,
    };

    const totalMonthly = Object.values(services).reduce(
      (sum, v) => sum + v,
      0,
    );

    return { totalMonthly, services };
  }

  private computeScalabilityScore(arch: ArchitectureJson): number {
    let score = 60;
    if (arch.autoscaling) score += 15;
    if (arch.alb) score += 10;
    if (arch.rds === 'multi-az') score += 10;
    if (arch.cloudfront) score += 5;
    return Math.min(score, 100);
  }
}

